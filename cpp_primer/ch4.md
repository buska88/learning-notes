# Ch4

## 4.1 基础

c++的表达式不是左值就是右值；当一个对象被用做左值时，使用的是它的身份(在内存中的位置)；被用做右值时使用的是它的内容(值)。

左值右值与运算符的关系：不同运算符要求左值或右值。如取址操作&，作用于左值，返回结果是右值。原则：需要右值的地方可以用左值代替，但是不能把右值当左值使用。

尝试理解一下这个原则

```c++
int a = getSize();//这里a是左值，getSize()是右值；
int b = a;//b是左值，它右边需要一个右值，但是这里可以把a作为左值，因为这里只是需要a的内容，并不需要a的位置
getSize() = 8;//wrong,不能把右值当左值使用，因为这里需要的是位置
```

表达式求值顺序

如果在一个表达式中改变了一个对象的值，在表达式的其他位置最好不要再使用这个对象避免未定义的行为

下面的执行顺序不确定，可能会先执行++i，也可能后执行，输出结果可能是 0 1,也可以是1 1

```c++
int i = 0;
cout << i << " " << ++i << endl;
```



## 4.2 算术运算符

所有算术类型都可以使用算术运算符执行运算

```c++
bool b = true;
bool b1 = -b;//b1=true，因为b=1，b1=-1 != 0
```

除法：除法得到商一律向0取整；

取余：m和n需要满足 m = (m/n) * n + m%n，-21 % (-8)取余就是-5



## 4.3 逻辑运算符

逻辑与&&和逻辑或||都是短路求值

相等性测试：val是一个对象，使用if(val)或if(!val)这两种写法会把val转成bool类型。



## 4.4 赋值运算符

- 赋值运算符左右两侧类型不同，右侧会强转为左侧的类型。int k = 3.14; k是3

- 赋值运算符的返回结果

  看起来赋值运算符是有返回结果的，结果就是左值

  ```c++
  int i, j;
  i = j = 8;//赋值运算符满足右结合率，这样写合法，i和j最后都是8
  int m, *p;
  m = p = 0;//wrong，这里p=0返回int * ，但是不能把int * 赋给int
  if(i = j) {}//这里i = j的返回结果是i的值，如果不是0的话那就是true
  ```

## 4.5 递增和递减运算符

i++:将对象原始值的副本作为右值返回

++i:将对象本身作为左值返回

非必须建议使用前置版本，因为后置版本多了存储原始值等不必要的操作

混用解引用和递增：*iter++ ：等价于*(iter++)，返回iter解引用的结果，并把iter移动1位

注意求值顺序的影响

大部分表达式都没有明确求值顺序

```c++
while(b != s.end() && !isspace(*b) {
  *b = toupper(*b++);//wrong。未定义的行为，是先赋值再移动b，还是先移动b再完成赋值
}
```

执行顺序不明确



## 4.8 位运算符

右移运算符：>>它是带符号右移还是无符号右移视环境而定

cout <<里的<<就是移位运算符

## 4.9 sizeof

返回对象所占字节大小，注意sizeof作用于引用、指针、数组、string/vector上的返回结果。

## 4.11类型转换

隐式转换：无需人工介入的转换

发生隐式转换的场景：

- 整形提升：表达式整形参与计算时，较小整形会转为较大的整形
- 无符号和带符号的转换：无符号和带符号类型进行计算，如果无符号的表示范围大于等于带符号，那么带符号会转往无符号；反之，要看具体的类型的大小关系决定转换方向(由机器决定)还是小的往大的转，比如unsigned和long相加，unsigned的表示范围大于等于long，那么带符号转无符号；否则无符号转带符号（看起来规则是范围小->范围大，带符号->无符号）
- 数组名转指针:int *p = arr
- 算术类型转bool：if(val)，此时val会被转为bool
- 非const指针/引用转换成const指针/引用：const int & rval = val;反过来的转换不被允许
- 类内自定义的类型转换：while(cin >> s) cin >> s返回cin(iostream类型)，因为io库定义了到bool的类型转换，所以会把cin转成bool类型。

显示类型转换：

- static_cast<double>(i)：具有明确要转成类型定义且不包含底层const，可用于把void*转成double*等带类型的指针
- char *p = const_cast<char *>(pc):只能用于改变底层const属性，可以让一个对象具有/失去底层const属性，具体用法参加6.4 不能通过它去实现static_cast一样的功能。如果pc是const char *类型的话，那么cast后p就不是底层const了，但是通过p去操作所指向的对象是未定义的行为。一般用于函数重载。
- reiterpret_cast:为运算对象提供位模式上较低层次的解释。比如可以把一个int*转成char*（意义何在？）

非必要不要使用类型转换