# c++知识点整理

## 1 变量和基本类型

### 1.1 内置类型

java：8大基本类型+引用类型；不同机器上类型长度都是一样的

c++ ：算术类型（整形+浮点型）+void，不同系统上长度可能不同。如long类型win、32位Linux下4字节；64位linux下8字节。除bool类型外其他整形分为signed和unsigned。像int、short这种就是带符号的，不带符号的前面会加个unsigned，无符号仅能表示大于等于0的值。char比较特殊，分为char、signed char和unsigned char3种，编译器决定char具体为后两者中的哪一种。因为char的这个性质，所以尽量不要用char参与运算。

* bool -> 整形：false -> 0, true -> 1；非bool类型 -> bool：0 -> false；非0 -> true
* 浮点数赋给整数会以小数点截断
* 给一个类型的值赋一个超过它最大区间的数：无符号类型会对这个数按照最大范围取余，有符号类型的结果未定义

切记：不要在表达式中混用无符号类型和带符号类型，有符号类型会转为无符号类型，如果这个带符号类型的数是负数的话，会出现错误的结果；也尽量别让无符号类型的数的计算结果最后为一个负数

**字面量**：像45,"hello"这种。可以给字面量加上前缀后缀指定它的具体类型：

如    L'a'(wchar_t类型字符) 100L(long类型)，100LL(long long类型)，3.24L(long double)

### 1.2 变量

初始化 ！= 赋值 （[类型 变量 = 值] 是初始化,[变量 = 值] 是赋值）

C++中引入了独特的列表初始化方式：

变量类型 变量1{初值1},变量2{初值2}

默认初始化：**函数体外**的的变量初始化为0（可以访问），**函数体内**的变量不会被默认初始化（试图访问会报错）

为支持分离式编译，C++将声明和定义分开，当多个文件使用同一个变量，就必须将定义和声明分离。定义可以只能出现在一个文件中，变量可以在多个文件中被多次声明。

**声明：**

* 规定变量的类型，名字
* 可以多次被声明，一个文件想使用别处的定义必须有对这个变量的声明
* extern int i;（声明）它告诉编译器存在着一个变量或者一个函数，如果在当前编译语句的前面中没有找到相应的变量或者函数，也会在当前文件的后面或者其它文件中定义，

**定义：**

* 为变量申请存储空间，赋初值
* extern int i = 0;定义变量（加上初始化语句后即使加上extern也不是一个声明了）

int i;即是声明，也是定义（C++14以后），只要没加上extern关键字都是定义，加上了才是声明，下例中在a.h中写了int i；而不是extern int i ;会被认为是重定义

使用extern的两种方式：

在a.cpp中定义一个变量int i = 10;，想让它在其他文件中被使用，需要：

1. 在a.h中声明它们extern int i，表明这个变量是给外部使用的（必须有这步，c++14视int i为定义操作否则会提升int i重定义）
2. b.cpp中要想使用i，要么引入a.h，要么声明extern int i 。 

### 1.3 复合类型

C++中通用的变量声明语句是：

基本数据类型  声明符 变量名

例如：

* int * p    p是一个int类型的指针
* int & p   p是一个int类型的引用

指针和引用都是复合类型，复合类型是基于基本类型得到的更复杂的类型

* 初始化：引用初始化时必须与一个**变量**（而非字面量或者该变量的地址）绑定，此后一直与这个变量绑定到一起；指针可以不显式初始化，也可以将指针设为空指针，不指向任何位置(int * p = nullptr/int * p = 0)。空指针可以当成false用，指向某个对象的指针可以当true用。对指针的==操作就是在判断两个指针地址是否相同
* 赋值：对引用的赋值就是对与引用绑定的对象赋值，对指针的赋值就是让指针指向一个新的内存地址
* 相互关系：指针是对象，引用不是。所以有指针的引用，没有指向引用的指针。int * &r = p：p是int型指针，r就是p的一个引用，它是int * 类型。对r的赋值操作就是让p指向新地址，对r的解引用结果等于对p的解引用结果。
* int& p1, p2。这里p1是引用，p2是基本类型。声明符只修饰它后面的那个变量，至于把它放在类型后还是变量前都是一样的。int* p1, p2也是一样的,p1是指针,p2是基本类型

### 1.4 const

const对象被初始化后，任何试图改变该对象的值的操作都将报错。

const对象默认文件内有效（因为编译器会将const对象替换为初值，所以不同文件const对象必须包含定义语句，让编译器知道它的初值是什么，然而c++不允许多次定义，所以就干脆设多个文件中出现的同名const变量是不同的变量）

如果必须要让const对象在不同文件之间共享，那就在头文件的声明语句和源文件的定义语句前都加上const（是的，extern const int i = fcn();定义前也加上const)

**常量引用**：

与普通引用只能绑定一个变量不同，常量引用可以绑定一个任意表达式（字面量、变量、计算表达式），只要这个表达式的计算结果可以转为常量引用的类型。double b = 3.13;const int & a = b;这种格式是可以的。因为编译器实际使用一个临时量temp：const int temp = b;const int & a = temp;引用a实际上没跟b绑定一起，而是跟temp绑定一起。打印a，输出的是3而不是3.13。假设a不是const的话，那么通过a修改b实际上修改的是temp，正因为常量引用这种特性，所以禁止对常量引用进行赋值操作。

当然，即使不能通过常量引用修改它所引用的对象的值，但是直接修改它的对象的话，常量引用的值也是会修改。

**常量指针&指向常量的指针**

顶层const<=>指针是个常量 <=>常量指针(int * const p) ，和其他用const修饰的基本类型(const int是顶层)

底层const<=>指针指向的对象是个常量 <=>指向常量的指针(const int * p) 、用于声明引用时使用的const也是底层const(const int & 是底层)

顶层const可以表示一切对象为常量，比如const int c = 0;这里的c不是指针是基本类型，但是依然是顶层常量。一般来说，顶层const表示它直接描述的对象的值时不变的，比如int * const p，它描述的p不能指向其他地方；const int r;不可以修改r的值

底层常量与指针、引用等基本类型有关，它指向的位置可以变，但是必须是常量，const int * p，p指向是可以变得，但是不能通过p修改它所指向得的值。

**常量引用仅对引用可参与的操作做了规定，不限制引用的对象本身是否是常量。**

如const int &r = i;//int i = 34;

这种操作是合法的，可用让顶层const作为左值去引用非常量，甚至这个i的值也是可通过别的途径改的，**只不过不能通过r改。**

```c++
	int b = 1;
	const int &r = b;
	cout << r << endl;//1
	b = 8;
	cout << r << endl;//8
//r只是与const int tmp = b;的临时量tmp绑定。
```

在赋值操作时，顶层const和底层const在当作右值时的区别：

* 当顶层const对象作为右值时

  ```c++
  int i = 0;
  const int ci = 42;//ci是顶层const对象
  i = ci;//可以，因为=代表拷贝操作，只是把一个常量的值浅拷贝给i了
  int &i1 = ci;//不可以，不允许修改ci的值，所以不允许通过常量引用i1去改变ci
  const int &i2 = ci;//可以
  int * const p = &i;//可以，这里p是顶层const，可通过p修改i的值
  int * const p = &ci;//不可以，编译器提示&ci是const int *类型，不能绑定到p上,p会修改ci
  ```

  

* 必须同为底层const = 底层const对象

  ```c++
  const int * p = &i;//可以，这里p是底层const，但是不可通过p修改i的值
  int *pp = p;//不可以，p所指向对象的值不能修改，但是pp却可以修改他所指向对象的值。
  i = i2;//可以，把一个底层const对象拷贝给int
  ```

  

总之，const对象作为左值时可以引用常量或是非常量，作为右值时简单拷贝一下是可以的（左值为Int类型），但是如果赋给一个有可能破坏它所指向的对象时(int &、int *)就不可以

这个性质影响到了函数重载。

**常量表达式：**

constexpr 基本类型 变量名 = 常量表达式

常量表达式指值不会改变且在编译阶段就能得到计算结果的表达式，字面量属于常量表达式。

将变量名前加上constexpr 的目的：可以让编译器验证这个变量是否是一个常量表达式

```c++
constexpr double d1 = d + 1;
```

### 1.5 对不同类型的处理

**typedef**：给类型起别名

typedef double wages;//给double起个别名叫wages

wages b, * p//等价于double b,*p

**auto**:对象类型未知时可用auto引用它，让编译器去推断它的类型

auto i = i1 + i2;

**decltype**:与auto作用差不多，也是类型推断，区别在于

decltype(表达式) 变量名 = 值；

decltype(f()) a = x;

这里将a的类型设为执行f()的返回结果，这里并没有执行f()，只是指定a的类型与f()返回的结果相同。

### 1.6 结构体

结构体内可以定义数据，也可以对数据进行初始化，没有初始化的数据将被默认初始化。

类的定义一般在头文件中，方便其他文件使用，比如book类，一般都是定义在同名book.h中。

有时同样的头文件，可能会被重复包含，为了解决这个问题，可用使用预处理器技术，它会在编译之前执行一段程序修改我们的代码，确保头文件被多次包含时任然可以正常工作。

在头文件中，可以这么写：

```
#ifndef A_H(自定义预处理变量名,一般为头文件名字的大写形式）
#define A_H
struct A{}；
#endif
```

当a.h第一次被包含时，A_H没被定义，所以#ifndef A_H返回true，然后通过define定义A_H，执行下面代码到endif；第二次包含a.h时，此时A_H已经被定义了，#ifndef A_H返回false，#ifndef A_H到#endif之间的部分会被忽略，A就不会再被包含。

## 2字符串、向量和数组

### 2.1 命名空间

我们使用的库函数都是在标准命名空间下的，比如cin、cout。没有指定标准命名空间而使用cin会报错

我们可以选择：

1. 引入每个名字的独立声明，如using std::cin；using std::cout；
2. 直接点明命名空间:using namespace std

头文件中一般不应使用using声明，因为头文件会将它的内容拷贝到所有引用它的文件中，可能会导致在某些文件下名字冲突。

### 2.2 string

string的初始化方式：

* string s1; //默认初始化，s1是空串
* string s1("haha")//直接初始化
* string s2 = s1/string s2(s1)/string s1 = "haha"   //两者等价都是拷贝初始化，编译器把等号右侧的值拷贝到新创建的对象中

c++中使用"="进行的初始化均是拷贝初始化，无关等式右侧是变量还是字面量，拷贝初始化的s2和s1是指向同一个地址吗？

不是。

```c++
int main() {
	string s1("haha");
	string s2 = s1;
	cout << s2 << endl;//haha
	s1 = "hehe";
	cout << s2 << endl;//haha
	system("pause");

	return 0;
}
```

"="只是浅拷贝，临时创建了一个s1的副本把它的值拷给s2，s1 s2不共享内存。

对string对象的读写：

**从键盘读入**：

* cin >> s；(这种读法会忽略字符串之间的空格、换行、制表，只读字符，而且遇见空格就不读了)，比如输入"hello world”，那s实际保存的只有hello；

* cin>>s1>>s2;这种读法可以使s1=hello,s2=world

* 读入数量未知时，可用使用while(cin>>s)判断是否有读入

* 如果不想让空格分割字符的话，那就while(getline(cin,s))，它会将一整段话读入到s里。直到遇见换行符为止，换行符也会被读进来。

  

**string相加**：

其实就是字符串拼接，因为C++兼容了C，所以字符串字面量并非C++的string对象。C++中执行字符串相加时注意+号旁边一定要有一个对象是string：

string s1 = (s2 + "ha") + "he"（正确，第一个括号结果可用string引用，最终结果可用string引用）

string s1 = ("he" + "ha") + s2（错误，第一个括号是字面量相加，编译器无法对字面量做加法）

与java不同，c++对string的==比较的是字符串的内容

### 2.3 vector

初始化方式：

* 默认初始化 vector\<T\> v；
* 拷贝初始化  vector\<T\> v(v1)；/vector\<T\> v = v1；
* N个元素   vector\<T\> v(n)；/vector\<T\> v(n,val);前者默认n个0，后者n个val
* 列表初始化 vector\<T\> v = {2,4,..,}；/vector\<T\> v{2,4,..,};

并非使用花括号就一定是列表初始化，列表初始化的前提是要把花括号内的值和vector的类型一致，如果出现这种情况vector\<string> v{10,"hi"};编译器会认为无法使用列表初始化，会把花括号当括号使用。

### 2.4 迭代器

所有标准库容器都可以使用迭代器，但是只有少数几种容器才支持下标运算符。

string不是容器，但是string也可以使用迭代器，也可以使用下标运算符。

**迭代器类型：**

* 读写迭代器    容器 \<泛型\> :: iterator
* 只读迭代器    容器 \<泛型\> :: const_iterator

const容器只能使用只读迭代器，非const容器两种都能使用；const容器的begin()返回只读迭代器，非const容器的begin()返回读写迭代器

**迭代器计算（通用）：**

it1==it2 it1!=it2：判断迭代器位置是否相等

++it /--it：迭代器移动到下一个元素/上一个元素

it->mem/(*it).mem：解引用迭代器并获取名字为mem的成员

**vector和string额外支持的迭代器计算：**

it+n/it-n： 结果是it向前、后移动n个元素的迭代器

it1-it2：it1和it2之间的距离

<,<=,>,>=：比较迭代器的位置

### 2.5数组

数组是被默认初始化的；定义数组时必须指明数组类型，不允许用auto；数组元素为对象，所以不存在引用的数组；

数组支持列表初始化，对于字符数组，可以使用字符串字面量进行初始化。注意C++中字符串字面量后面会有一个'\0'。所以要使用"haha"初始化一个字符数组时要留出5个空间。（以后自己用就使用列表初始化吧）

不允许将一个数组以拷贝初始化的方式初始化另一个数组，也不能使用一个数组为另一个数组赋值。

指针、引用和数组：

```c++
int *parr[10];//parr是包含10个int指针的数组
int arr[3];
int (*p)[3] = &arr;//指向数组arr的指针，注意这里指针必须要点明数组长度，int (*p)[]会报错
int (&r)[3] = arr;//r是arr的引用
```

**指针和数组：**

int * p = arr;//int * p = &arr[0];

p指向数组首元素。

int * p和 int (*p)[3] 有什么区别：

看下面代码：

```c++
	int arr[3] = { 1,2,3 };
	int(*p)[3] = &arr;//指向数组arr的指针，注意这里指针必须要点明数组长度，int (*p)[]会报错
	int(&r)[3] = arr;//r是arr的引用
	int * pp = arr;
	for (int i = 0; i < 3; i++) {
		cout << sizeof(p) << endl;
		cout << "arr: " << &arr[i] << endl;
		cout << "p: " << p++ <<  endl;
		cout << "pp: " << pp++ << endl;
	}
```

输出结果：

```
4
arr: 0113FA0C
p: 0113FA0C
pp: 0113FA0C
4
arr: 0113FA10
p: 0113FA18
pp: 0113FA10
4
arr: 0113FA14
p: 0113FA24
pp: 0113FA14
```

对于一个长度为3的数组，p和pp指向的都是首地址

然而，做++操作时，pp一次前进4字节，指向数组中的下一个元素。p前进了12个字节（整个数组长12字节），虽然该指针大小只有4字节。但是它++后指向的范围已经不在数组内了

指针本质上也是迭代器，容器的begin和end可以返回迭代器，数组的类似操作为

```c++
int a[10];
int * b = &a[0], *e = &a[10]//是的，a[10]也可以，e是指向数组的尾后指针
```

C++11引入了库函数得到首元素指针和尾后指针，因为这种有可能出错

```c++
int a[10];
int * b = begin(a), *e = end(a);//和上面一样
```

p是一个指向数组位置i的指针，p+n是指向数组第i+n个位置的指针。

多维数组的指针问题：

```c++
int arr[3][4];
int (*p)[3][4] = &arr;
int (&r)[3][4] = arr;
int (*pp)[4] = arr;
```

此时指向多维数组首地址的是一个int * [4]类型的指针（第1行）

如何通过指针遍历多维数组？

```c++
	int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
	int(*p)[3][4] = &arr;
	int(&r)[3][4] = arr;
	for (int (*pp)[4] = arr; pp != arr+3; pp++) {
		cout<< "pp: "<< pp << " " << *pp << endl;
		for (int *q = *pp; q != *pp + 4; q++) {
			cout << "q: "<< q << " " << *q << endl;
		}
	}
```

输出结果：

```
pp: 004FFD14 004FFD14
q: 004FFD14 1
q: 004FFD18 2
q: 004FFD1C 3
q: 004FFD20 4
pp: 004FFD24 004FFD24
q: 004FFD24 5
q: 004FFD28 6
q: 004FFD2C 7
q: 004FFD30 8
pp: 004FFD34 004FFD34
q: 004FFD34 9
q: 004FFD38 10
q: 004FFD3C 11
q: 004FFD40 12
```

可见pp每次前进12字节，q每次前进4字节；对(int * [4]）类型的pp解引用的结果是(int *)类型的指针，指向pp指向的首元素的指针。pp可以看作指向指针的指针，对它解引用的结果是指向数组首元素，类型与数组类型相同的指针。

## 3表达式

类型转换可以分为显式类型转换和隐式类型转换

### 3.1 隐式类型转换

**算术转换**

在运算表达式中，两个不同类型的数进行计算时，结果会转为较大的类型。C++中不同系统不同类型占内存不同，一个int至少要和一个short一样大，一个long至少要和一个Int一样大。

* **整形提升**：如char,bool,short,unsigned short在**只要它们所有可能的值都能存在int里**就会转为int类型，如果int装不下的话，就转为unsigned int。对于较大的char类型(wchar_t、char32_t)，他会提升为int、unsigned int、long等最小的且能容纳它的类型
* 当运算符的两个运算对象一个有符号，一个无符号时，首先会进行整形提升，如果提升之后类型相同那就无须进行下一步转换
  * 整形提升之后，如果类型不匹配，但是同为带符号的或不带符号的(一个是unsigned int,一个是Unsigned long），那么小类型转为大类型
  * 如果一个带符号，一个不带符号，那么（都是往占内存大的方向转）：
    * 无符号类型大于等于带符号类型，转为无符号类型(int和unsigned int，转为unsigned int)
    * 无符号类型小于带符号类型，无符号的**所有值能存在带符号的范围内**，转为带符号类型；
    * 比如unsigned int 和long，如果int和long大小一致，那么就转为unsigned int,如果long大于unsigned int的话那就转为long。

**其他隐式类型转换**

* 数组转为函数类型指针：

  int * p = arr;//p转为指针

* 常量和非常的转换

  可以用一个常量的指针和引用作为一个非常量的指针和引用的左值，但是反过来就不行

* 类类型定义的转换

  比如while(cin >> s)，这里s是字符串，括号里需要一个bool值，但是cin>>s返回的是istream类型的值，IO库定义了从istream向bool的转换规则，如果读入成功，则转为true

### 3.2 显式类型转换

强制转换语法：

cast-name\<type\>(expression)

* type 要转换的目标类型
* expression转换的值

常见的cast_name:

* static_cast：不包含const时的类型转换，比如强制执行浮点数除法：double  b = static_cast\<double\>(i) / j;

* const_cast：将常量转为非常量，也可以将非常量转成常量:

  ```c++
  const char *pc;
  char *p = const_cast<char *>(pc);//可以对p赋值了
  ```

  

## 4 语句

for 语句

c++有范围for(类似java增强for)，可用于遍历序列：

```c++
for (char c : str) {}
for (auto c : str) {}//遍历字符串
```

vector，数组也支持这种写法

## 5 函数

### 5.1 函数基础

自动对象：只存在于块执行期间的对象，比如形参，当函数执行完毕形参销毁

局部静态对象：static修饰，函数结束时依然存在，程序结束时才销毁。

**分离式编译**：

函数的声明应该放到头文件中（放到源文件也合法），定义放到源文件中。比如fact函数定义在fact.cc中，而fact的声明定义在fact.h中，fact.cc需要包含fact.h，编译器会检查声明和定义是否匹配。

假设我们定义的factMain文件(包含main函数)要调用fact函数，那么我们应该在factMain中包含fact.h，编译时会：

* 编译factMain.cc和fact.cc生成对象代码(win是factMain.obj和fact.obj，unix是factMain.o和fact.o)
* 连接factMain.obj和fact.obj生成可执行文件factMain.exe
* 生成main或main.exe

### 5.2 参数传递

值传递（形参和实参是两个不同的对象），引用传递（形参绑定到实参上）

什么时候使用引用类型？1.希望可用修改实参的值2.当实参较大时，使用值传递将其拷贝到形参上效率很低，这个时候使用引用传递

形参可以用const修饰，const类型形参可用接收const和非const的实参，反过来则不可以，赋值规则和等号一样，比如const int * 类型的形参可以接int *，int &类型的形参不能跟字面量。在引用传递时可用将形参用const修饰，避免被修改。

**数组形参**

c++中数组两个特性：1.不允许拷贝数组2.使用数组时通常会将其转成指针

那么因为1，我们不能以值方式传递数组；因为2，我们不能传递数组时传递的是首地址的指针。

```c++
void f(const int *) <==> void f(const int[]) <==> void f(const int[10])
```

上面三种形参是等价的，也就是说，形参为const int[]的函数可以接收&i作为实参(int i = 0)；好神奇。

这样的传参方式需要保证数组不越界：

* 使用库函数的首指针和尾后指针：

  ```c++
  void f(const int *b, const int *e)//形参
  f(begin(arr),end(arr));
  ```

* 显式传参指定数组大小

  ```c++
  void f(const int *a, int size)//形参
  f(arr,end(arr)-begin(arr));
  ```

  

也可以选择通过引用的方式传递参数，这样形参不是指针而是绑定到实参上的引用：

```c++
void f(int (&arr)[10])//注意不要写成f(int &arr[10]),这样表示包含10个引用的数组
```

这种方式对于&i(int i = 0)、int j[2] = {0,1}类型的实参都无法接收，他只能绑定到元素个数为10的数组的实参上

当传递的是一个多维数组时，传递的同样是数组的首指针：

```c++
void f(int (*mat)[10],int size)//形参
int matrix[3][10];
f(mat,3);    
```

给main函数传参：

```c++
int main(int argc, char* argv[])//argc为argv中元素个数，argv第一个元素指向程序名字或空串，后面的才argc-1个元素是实参
int main(int argc, char** argv)       
```

可变形参参数：

```
void f(initializer_list<T> lst)
```

initializer_list是个模板类，可以用于接收类型相同，数量不定的实参，T为数据类型。

### 5.3 函数返回

返回函数值的方式与初始化一个变量或形参完全一样，返回值用于初始化调用点的一个**临时量**。比如函数要返回一个字符串s，那么会将s复制一份然后传递给调用者。

```c++
string func(string &s) {
	cout << "s: " << &s << endl;//s: 00B8F940
	return s;
}

int main() {
	string str("haha");
	cout << "str: " << &str << endl;//str: 00B8F940
	cout << "调用后: " << &func(str) << endl;//调用后: 00B8F85C
	system("pause");
	return 0;
}
```

可见，函数返回的只是一个副本。

不要返回局部变量的指针或引用。

当函数返回的是引用时，可以把它作为左值（如果返回的是常量引用就不能给它赋值了）。

可以返回一个列表(例如{"haha","hehe}），对临时量进行列表初始化。

Main函数可以不写return语句，编译器会插上一个return 0;

**返回数组指针**：

一个参数为i，返回一个指向具有10个元素的数组的指针，它的声明为：

```c++
int (*func(int i)) [10];//(*func(int i))[10]表示可以对函数返回值解引用，且得到是大小为10的数组。
```

如果觉得这样定义太麻烦，也可以使用尾置返回类型，

auto func(int i) -> int (*)[10]

其中auto表示真正的返回类型在后面

### 5.4 重载

顶层const不支持重载，const int a 和int a是一类参数，原因在于：

1.const int 类型既可以支持int类型的实参也可以支持const int类型的实参

2.int 类型既可以接受int类型的实参也可以支持const int类型的实参

两者完全没区别，所以不支持重载。

而底层const支持重载：

1. const int * /const int &可以接受常量和非常量

2. int */int &无法接受一个底层const，详见1.4，底层const要求左值也是底层const

### 5.5 其他函数特性

**内联函数**：在函数f的返回值类型前加上inline关键字，就可以将其声明为内联函数。

```c++
inline int f(int &a,int &b){
    return a + b;
}
```

当某函数ff调用f时，直接使用f里面的函数体，这样可用免去函数调用时寄存器的那一堆操作

cout << f(1, 3)<< endl;直接改为cout << 1 + 3<< endl;

但是这个inline只是表示对编译器的一个请求，编译器可能忽略这个请求；内联一般用于规模小，调用频繁的函数。

**assert**：预处理宏，包含在assert(expr)，当表达式expr的值为真时什么也不做，否则终止程序，它定义在cassert头文件中。

**constexpr函数：**

是指能用于常量表达式的函数，函数体必须有且只有一条返回语句，返回类型和形参是字面值。

```c++
constexpr int f(int cnt) {return cnt + 100;}
constexpr int a = f(100);//可以,a是常量表达式,f()可以用在任何常量表达式的位置
int i = 100;//i不是常量表达式
constexpr int b = f(i);//不可以，改成int b即可
```

执行对a的初始化任务时，会把f()替换为结果值。

注意constexpr函数运行返回一个非常量，只要这个函数的结果满足上下文要求。看上面的例子，当传入f的参数是一个常量表达式时，它返回的也是一个编译时就能确定的常量表达式，那么f(100)也属于一个常量表达式，可以赋值给a;如果传入的说一个变量i，它返回i+100，这不是常量表达式，所以无法赋值给constexpr int b，赋给int b是可以的。

### 5.6 函数匹配

函数重载涉及到函数匹配：

* 确定候选函数（同名，其声明在调用点可见）
* 确定可行函数（形参与实参数量相等，类型相匹配或者可用转换为匹配的）
* 确定最佳匹配

当一个函数为最佳匹配时，它必须每个参数都不劣于其他参数，而且至少有一个参数优于其他参数。当在多个可行函数时找不到最佳匹配会报二义性调用错误。

如f(42,2.56)在f(int,int)和f(double,double)中选，它们俩各有一个参数优于对方，所以找不到最佳匹配。

匹配度层级（由1到5匹配度下降）

1. 类型完全相同，或者数组、函数，形参为数组和函数的指针，或者顶层const形参-普通实参或顶层const实参-普通形参。
2. 形参为底层const，实参非常量
3. 类型提升 int/unsigned int类型的形参     和short，bool类型的实参
4. 算术类型转换（所有算术类型转换是平级）或指针转换（指向任意非常量对象的指针转为void* ,指向任意对象的指针转为void*）
5. 类类型转换

### 5.7 函数指针

函数类型：返回值(参数列表)，例如bool f(const string&)

函数指针：指向某种函数类型

函数指针的声明：用指针替换函数名

```c++
bool (*pf) (const string&)//pf为指向bool f(const string&)类型的指针
```

括号不能少，否则就是返回指向bool指针类型的pf函数。

**与数组相同，把函数当成一个值，该函数自动转为指针：**

* ```c++
  pf = f;//和数组很像，函数f可用pf引用
  pf = &f;//这个正规一点，对f取值赋给pf
  bool b1 = f("haha");
  bool b2 = pf("haha");
  bool b3 = (*pf)("haha");//三者等价
  ```

* 返回指向函数的指针时也跟数组类似：

  ```c++
  //函数f1返回指向bool f(const string&)类型的函数指针,对f1的声明为：
  bool (* f1(int)) (const string&);//f1是个函数，参数为int，对它解引用的结果是一个函数
  auto f1(int) -> bool(*)(const string&);//尾置返回类型
  ```

* 类型为函数类型的形参会自动转为指向函数的指针，调用时传入函数对象作为实参：

  ```c++
  void ff(bool (*pf) (const string&));
  void ff(bool pf (const string&));//自动转为函数指针
  ff(f);//调用时传入函数
  //如果觉得函数指针过于冗长也可以选择定义类型别名：
  typedef bool Func(const string&);
  void ff(Func);//这里Func就是bool(const string&)类型的别名
  ```

  

不同类型的函数指针不存在转换规则，所以把函数类型赋给一个函数指针时，一定要保证**参数列表和返回类型**是完全对应的：

```c++
bool f1(const char *);
int f2(const string&);
bool f3(string&);
```

将pf指向f1,f2,f3都会报错的，因为虽然string是管理char *的容器， char * 和string&类型的形参都可以接受一个string类型的实参，但因为函数指针不存在转换，所以f1和f被认为是不同的类型；同理因为不存在const到非cosnt的转换，f3和f也是不同的类型。

## 6 类

### 6.1 抽象数据类型

类的成员函数的声明必序在类内部，成员函数的实现（定义）可以在类内也可以在类外。

**关于this：**

类Book下内成员方法isbn，book为Book的对象，book.isbn()等价于编译器将该调用写成Book::isbn(&book)，将book的地址传给了isbn函数的隐式形参this。this是一个**常量指针**，不允许修改this中保存的地址成员函数有一个额外的隐式参数this访问当前对象。可以在成员函数体内直接访问成员对象，因为这被看作隐式使用了this.xxx来访问该对象。

返回this 对象：

return *this;//对this解引用返回当前对象

**关于const成员函数：**

默认this的类型是 Book const *，指向Book类的一个常量指针（顶层const)。this本身要遵守初始化规则，因为不能把一个const对象赋给一个常量指针（该指针可以修改const对象的值），不能把this绑到一个常量对象上。

```c++
const Book book;
Book * const this = &book;//错误，因为可以通过this修改book，&book是const book * 类型。
```

这导致我们不能在常量对象上调用普通成员函数，要使对象可以调用成员函数，必须把this声明为：const Book * const this,所以我们在成员函数后加上一个const,表示this是一个指向常量的指针。

```c++
string isbn() const {}
```

这样的成员函数被称为常量成员函数，因为this是指向常量的指针，所以不能通过常量成员函数修改这个对象的值。

**成员函数类外实现：**

类外实现时需要保证函数类型、函数名字、后面是否加上const与类内定义时保持一致：

```c++
double Book::avg_price() const{
    return sell_price;//即使是类外实现，加上作用域Book之后，也可以在函数体内访问Book的成员sell_price
}
```

Book：：告诉编译器该函数被声明在Book内

**与类相关的非成员函数：**

有些函数与类有关，但是不属于类本身，这些函数的声明应该与类声明处于一个头文件内，

**构造函数：**

不能被声明为const，因为创建一个const对象时，只有在构造函数完成初始化后，这个对象才真正具有常量属性。

编译器在我们没有显式定义构造函数时会提供默认构造函数（也叫合成的默认构造函数），它优先根据类内初值初始化成员变量，否则执行默认初始化。

默认构造函数的局限性：

* 与定义在块内的内置类型、数组、指针被默认初始化后值是未定义的一样，类的内置类型、数组类型、指针类型成员如果仅使用编译器提供的默认初始化函数去初始化，那么它们的值也是未定义的。
* 类内某个类型的成员没有默认构造函数，那么编译器无法为该类合成默认构造函数。

构造函数初始值列表：

```c++
Book(const string &s, int p):bookNo(s),price(p) {}
```

上面的构造函数给类成员bookNo和price赋值，也可以选择不通过这个初始值列表，在函数体内实现赋值操作。

如果有的成员被构造函数初始值列表忽略了，该成员会被默认初始化（先看是否直接定义了初值，否则赋一个未定义的值）

也可以选择在类外实现构造函数：

```c++
Book::Book(const string &s, int p) {}
```

对象被拷贝的几种情况：

* 初始化变量
* 以值的形式返回或传递一个对象

对象被赋值的情况：使用赋值运算符

对象不再存在时执行析构操作。

编译器可以合成拷贝、赋值和析构操作，但是有些类不能依赖合成版本。

### 6.2控制访问与封装

class 和struct都可以用于定义类，内部也可以使用public或private这样的访问说明符，只是在没有使用访问说明符时，前者默认所有成员都是private的，后者默认所有成员都是private的。

对于非成员函数，它们是不能访问类的private成员的，只有在类内声明一下这个函数为友元才允许其访问类内成员。

```c++
class Book {
    friend int get_price();//友元声明，非成员函数get_price可以访问Book类的私有成员
}
int get_price();//函数声明
```

当类的定义发生改变时无需更改用户代码，但是使用了改类的源文件必须重新编译。

注意友元声明不等于函数声明，它如果要被调用必须有函数声明。一般把访问类内成员的函数声明和类本身放在同一个头文件外部。

### 6.3 类的其他特性

**类型成员**

```c++
class Book {
public:
    type string::size_type pos;//类型成员
    pos pages = 0;
}
```

在Book类中定义了类型成员pos，用于指代size_type类型，定义它之后在类内就可以使用这个类型去声明数据了，类型成员必须先声明后使用，所以位置一般在开始位置。

也可以使用using pos = string::size_type

**inline:**

类的成员函数是自动inline的，当然也可以显式声明inline,可以在类内部函数的声明那里将其声明为inline，也可以在函数定义处将其声明为inline

**mutable:**

有时候，我们希望可以修改类内某个成员，即使是一个const对象（比如统计这个const对象内某个成员函数被调用的次数）也有这种需求。我们可以将那个对象声明为mutable，即使是const对象也可以调用const方法修改mutable成员的值。

**类内初始值：**

必须使用=的形式或{}的形式，如：

```c++
class Book{
    int price = 1;//使用等号
    vector<string> authors{"yan","susan"}//使用花括号
}
```

**返回*this的成员函数：**

```c++
class Book{
    Book & set_price(int a) {
        price = a;
        return *this;
    }
}
```

如果返回的是Book&，那么就是返回的是当前this的一个引用，相当于Book& b = set_price(20)对返回值进行操作还是可以修改当前对象；如果返回的是Book，相当于Book b= set_price(20)，这里b只是一个临时量，是对原对象的copy，对b操作不会修改原对象。

对于const成员函数，它如果也要返回*this，那么这里的 this是一个指向常量的指针（底层const），所以也要使用一个const引用（底层const)去接收

```c++
    const Book & set_price(int a) const {
        price = a;
        return *this;
    }
```

上面的两个函数形成了重载，虽然它们参数相同，但是别忘了隐式参数this却不一样，上面的this不是底层const而下面的this是底层const。对于一个常量对象，它只能调用下面的set_price函数，对于普通对象，它两个都可以调，但是如果调下面那个涉及到5.6中用底层const去绑定到到非常量对象上，匹配优先级比上面的函数更低，所以会非常量对象会优先调用上面的set_price函数。

**类的声明：**

我们可以声明类但是不去定义它。

class Book;

这种声明被称为前向声明，它引入了Book，指明它是一个类。在这个声明之后到Book具体被定义之前Book属于不完全类型，不清楚它具体包含的成员。可以定义指向不完全类型的指针和引用(Book *)，也可以**声明**（不能定义）以不完全类型为参数和返回类型的函数(f(Book b))

不完全类型有什么用？

对于一个类，创建它的对象该类必须被定义过，不能仅被申明过，类必须要被定义然后才能访问其成员。

例如定义一对类，X中包含Y的指针对象，Y中包含类型为X的对象：

```c++
class Y;//前向声明
class X {
public:
	Y* y;
	X() {}
	X(Y* y1) {
		this->y = y1;
	}
};

class Y {
public:
	X x;
	Y(X x1) {
		this->x = x1;
	}
	Y() {}
};

int main() {
	X x;
	Y y;
	y.x = x;
	system("pause");
	return 0;
}
```

如果没有Y的前向声明，上面的代码会报错的，会提示y不是X的成员，因为此时Y既没有被声明又没有被定义，编译器不认识Y，前向声明过后可以定义指向Y的指针了。

上面的代码如果X和Y的定义调换顺序，并且前向声明X会报错，因为只能定义指向不完全类型的**指针或引用**，不能直接把不完全类型当作类的成员类型。

**类友元：**

除了可以把函数定义成友元，也可以把类BookStore定义成友元，被定义为友元的类的成员函数可以访问Book类的price，也可以把其他类的成员函数定义成友元。

```c++
class Book;//BookStore类中用到Book类了，所以先声明一下
class BookStore {//定义类，但是没有实现buy函数，只是声明buy函数，因为buy内部还不能访问Book私有成员
public:
	int buy(Book & b);//在类内定义
};

class Book {//Book类定义，声明友元
friend class BookStore;//Book类内定义友元BookStore
public:
	Book(int p) :price(p) {};
	Book() {};
private:
	int price;
};

int BookStore::buy(Book & b) {//类外实现
	return b.price;//可以访问Book类内成员
};

int main() {
	Book book(10);
	BookStore bs;
	cout << bs.buy(book) << endl;//10
	system("pause");
	return 0;
}
```

注意上面的声明、定义顺序是互相依赖(c++primer p252提到的顺序）的，少定义一个就会报错：

* 声明Book是因为后面的BookStore类中buy函数会用到Book类型的参数，此时Book是不完全类型，可以作为buy函数的参数类型；
* 定义BookStore类，点明它内部的成员，但是不实现buy函数，定义BookStore是因为要把它声明为Book类的友元
* 定义Book类，声明友元
* 实现buy函数，在buy函数内部可以直接通过Book对象访问price（不能直接范围price，但是可以通过Book对象访问price）。

当然上面的顺序也不是固定的，使用下面的顺序也可以：

```c++
class Book {
friend class BookStore;//Book类内定义友元BookStore
public:
	Book(int p) :price(p) {};
	Book() {};
private:
	int price;
};

class BookStore {
public:
	int buy(Book & b);//在类内定义
};

int BookStore::buy(Book & b) {//类外实现
	return b.price;//可以访问Book类内成员
};
```

声明一个类做友元时，不一定要实现声明或者实现这个类，上例前面就没有声明BookStore类。(c++14亲测）。

也可以直接将buy函数声明为友元：

friend int BookStore::buy(int totalprice);//这里要指明这个函数属于哪个类，如果没有前面的BookStore那么buy就是一个普通函数了。

相让一组重载函数做友元时，需要将每个函数分别声明为friend，只将一种声明为友元了，另一种是没办法访问类的私有成员的。

**友元&作用域**

**注意，在友元函数中不能出现this,this只能出现在成员函数中。**

把一个非成员函数、类定义为某个类内的友元，它们本身的声明不一定非要出现在它们的友元声明前。

*我们即使在类内就把友元函数定义了，那也得在外面声明一下函数使得函数可见，即使只能仅使用声明友元的类成员调用友元函数，它也必须是被声明过的。*

上面这段话来源于cpp primer 252,我用c++ 14的vs studio2017试了一下好像不用声明也可以：

```c++
class Book {
public:
	friend int f(Book *b) {
		return b->price;
	}
	Book(int p) :price(p) {};
	Book() {};
	int ff();
private:
	int price;
};
//int f(Book* b);可以不用声明
int Book::ff() { return f(this); }
int main() {
	Book book(300);
	cout << book.ff() << endl;//300
	system("pause");
	return 0;
}
```

上面的例子把友元函数定义在类内，类外也没声明，但是还是可以在成员函数ff内调用f的。

但是在下面这个例子里就必须在类外声明f()了，否则会提示找不到f：

```c++
class Book {
public:
	friend void f() {
		cout << "hh" << endl;
	}
	Book(int p) :price(p) {};
	Book() {};
	void ff();
private:
	int price;
};
void f();//必须声明，否则找不到
void Book::ff() { f(); }
int main() {
	Book book(300);
	book.ff();
	system("pause");
	return 0;
}
```

为什么会出现这种区别？这个似乎与友元函数的参数有关，如果是空参的话必须要声明f，否则不用声明。

不过声明一下总没坏处。

### 6.4 类的作用域

外面选择成员函数类外实现时会加上 类名::函数名，这是告诉编译器，此时函数的参数列表和函数体就已经位于函数体中了，**但是返回类型还是位于类的作用域之外**。

```c++
class A {
    using ST = vector<string>::size_type;
    ST f();
}
//如果A的某个成员函数f返回类型为ST的话，那么需要在实现时点明ST是A中的
A::ST f() {
    //实现
}
```

**名字查找：**

对于一个名字，编译器在名字所在的块中寻找声明语句，只考虑名字使用之前的声明，如果没找到，再寻找外层作用域直到报错。

一、解析定义在**类中成员函数声明中的名字**与上述规则有不同之处，在一个类中，首先编译所有成员的声明，直到类可见后再编译函数体。

```c++
typedef double Money;
class Account {
public:
    Account(Money v) { val = v; }
    Money balance() { return val;}
    double f();
private:
    typedef double Money;//重复定义
    Money val;
};
double h = 10;
double Account::f() {
    return h + val;
}

```

上面的Account首先会处理balance函数、f函数，val变量的声明，等到这些处理完之后才会处理balance函数、f函数的定义，在处理balance函数时发现类内且这个balance前没有Money的声明于是继续往前找，发现它是double。

如果成员已经使用了外层作用域的某个名字，而且该名字代表一个类型，则类不能在之后重新定义该名字，否则就是重复定义。

二、解析定义在**成员函数体内使用的名字**查找顺序：

1. 成员函数内，该名字出现**之前**的声明
2. 类内所有成员（不用非得在之前了）
3. 成员函数定义之前的作用域

这里值得注意的是第1条，即使在成员函数内也必须要在使用之前，假设我们在上例中去掉double h = 10;然后这样实现f：

```c++
double Account::f() {
	return h + val;
	double h = 10;
}
```

会提示h找不到，所以函数体内的h一定要定义到使用之前。

关于第3条，上例可以看到，对于类外实现的成员函数，如果找不到某个名字的话也可以在它的实现之前的作用域找，比如h虽然没有声明在f()的声明前，但是定义到f的实现之前，所以f内部还是可以找到h的。

### 6.5 构造函数

6.1中提到的构造函数初始值列表和构造函数体有啥区别？

前者相当于初始化操作，后者相当于赋值操作。两者区别在于，如果没有在构造函数初始值列表中显式初始化成员，该成员将在执行构造函数体之前执行默认初始化。也就是说，等构造函数体执行的时候，成员已经是被初始化过的了。

有些时候，比如有的成员为const或引用类型时，必须要求使用构造函数初始值列表，比如下例：

```c++
class X {
public:
	X(int i):i(i),ri(i),ci(i) {
		//this->i = i;
		//ci = i;
		//ri = i;
	}
private:
	int i;
	const int ci;
	int &ri;
};
```

这里的需求是要把X的常量成员ci和引用类型成员变量ri绑定到传入的参数i上，那么首先肯定不能直接对其赋值了，它最后被初始化的机会就是在构造函数的初始值列表上，在那可以根据参数值对成员初始化。如果没有使用初始值列表的话而是只在构造函数体内进行赋值，会报错。因为const和引用是必须要被初始化的，不能只靠默认初始化。

初始值列表的初始化顺序取决于成员的出现顺序，不是它们在初始值列表中的顺序，上面ci的初始化顺序在ri之前。

**委托构造函数：**

一个构造函数可以调用其他构造函数，语法在初始值列表的位置以**类名（参数列表）**的形式调用匹配的函数。

上例的默认构造函数可以定义为

```c++
X():X(0) {}
```

它调用的是X(int i)

被调用的构造函数会以此执行它的初始化列表和函数体，然后控制权回到调用者。

**默认构造函数：**

当对象被默认初始化或值初始化时自动执行默认构造函数。

默认初始化(p40)：定义变量时没有指定初值，则变量被默认初始化，块外被初始化为0，块内值是未定义的。

值初始化（P88):一些特殊的类会提供一些初始值作为元素初值，比如vector\<int\>使用0为每个元素赋值，vector\<string\>中的元素由类默认初始化。

在以下情况发生默认初始化：

* 在块内不使用初始值去定义一个非静态变量或数组，此时该变量和数组的值未定义

  ```c++
  int main() {
  	int arr[10]; 
  	cout <<arr[0] <<" "<< arr[2] << endl//-858993460 -858993460
  	system("pause");
  	return 0;
  }
  ```

* 当一个类A本身含有类类型成员B且A使用合成的默认构造函数时（合成默认构造函数首选看是否存在类内初值(通过=赋值)，否则执行默认初始化）

* 类类型成员没有在构造函数初始值列表中显式初始化时，那么这个成员就会被默认初始化。

在以下情况发生值初始化：

* 数组初始化时提供的初始值数量少于数组大小，剩下的数组元素会以默认值被初始化(内置类型是0)
* 不使用初始值定义一个局部静态变量，此时局部变量执行值初始化，内置类型初始值为0
* 执行 **T 变量名()；**这种形式显式请求执行值初始化，比如vector\<int\> v(10)就是以值初始化的形式初始化一个包含10个元素的vector，每个元素初值为0。

**类的隐式转换规则：**

如果构造函数只接受**一个实参**，那就相当于定义了实参类型到这个类的隐式转换机制，定义这种构造函数为转换构造函数。

```c++
class X {
public:
    X(String &ts) {
        s = ts;
    }
private:
    String s;
};
```

假设item.f(X x)函数需要一个X类型的参数，我们可以传入一个String:

```c++
String tmp = "haha";//发生了 字面量->string对象的隐式转换
item.f(tmp);//发生了  string->X的隐式转换
```

这里编译器用"haha"自动创建了一个X对象，然后作为f的参数。

但是只允许一步类类型转换，

```c++
item.f("haha");//不允许，因为发生了两次类型转换
```

也可以在转换构造函数前声明explicit阻止隐式转换：

```c++
explicit X(String &ts);
```

无需在多参数的构造函数前定义explicit，此外如果采用类外实现的话应该在类内声明位置定义explicit，不应该在类外定义的时候使用explicit。

当构造函数X(String &ts)使用explicit修饰后，只能使用该构造函数用于直接初始化，不能用于拷贝初始化：

```c++
X x("haha");//可以，直接初始化
X x = "haha";//不可以，不能将explicit修饰的构造函数用于拷贝初始化过程
```

即使使用了explicit修饰，但是还是可以通过强制转换的方式，把一个string转成一个X对象，

```c++
s = "haha";
item.f(static_cast<X>(s));
```

这里将X的构造函数用explicit修饰后，依然可以用强制转换的方式将string对象s转成X对象。

**聚合类：**

* 所有成员都是public的
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类和virtual函数

```c++
struct Data {
    int a1;
    string a2;
}
//Data就是聚合类
//定义一个聚合类对象：
Data d = {10,"haha"};//使用花括号括起来
```

聚合类初始化时花括号中元素顺序与类中成员定义顺序要一致，如果花括号元素个数小于成员个数，那么后面的元素将被值初始化。

**字面值常量类**

数据成员都是字面值类型的聚合类是字面值常量类。

字面值常量类必须提供一个constexpr构造函数：

```c++
constexpr X(bool b):x1(b) {}
```

constexpr构造函数要么声明成=default，或者删除函数的形式，否则就既要符合构造函数的要求（不能包含返回语句），又要符合constexpr函数的要求（函数体必须有且只有一条返回语句，返回类型和形参是字面值），相冲突了。所以函数体一般应该是空的，通过函数初始值列表为成员赋值。

### 6.6 类的静态成员

静态类型成员可以是常量、引用、指针，类类型。

* 静态成员函数不能与任何对象绑定在一起，它们不包含this指针。
* 不能将静态成员函数声明为const，否则const对象能调这个函数，非const对象不能调这个函数，这就不是类层面的概念了
* 不能在static函数体内使用this指针

访问静态成员：

* 直接通过域作用运算符：类名::静态成员
* 也可以通过对象调用静态函数

**静态成员函数**：既可以类内定义也可以类外定义，在类外定义时不能使用static关键字，在类内声明时使用一次就够了。

**静态成员数据**：不能在类内初始化静态成员，必须在类外定义和初始化静态成员，一个静态成员只能定义一次。

静态成员不能在类内初始化，但是可以为静态成员提供const类型的类内初始值，此时要求静态成员用constexpr修饰。

在类外定义非constexpr静态成员的时候，这里选择使用了一个类内私有函数，这样做是可以的，类外定义静态成员的时候，类名后的部分都处于类的作用域之中，所以这里是可以调用私有函数，这是static成员的一个特点，直接用类名访问的话类名之后就在类的作用域中，而非static成员只能通过对象去访问，没有这种特点。

对于constexpr静态成员,在类内定义之后就不能在类外再指定初始值了，cpp primer271说如果要把p赋给一个接受const int&参数时需要在类外以下面的方式再定义一下静态成员（不要提供初值） 

constexpr int X::p;

否则会找不到该成员的定义语句出现编译错误，不过我试了一下啊好像没问题，

```c++
int f1(const int& a) {
	return a;
}
class X {
public:
	X(){}
	static int a;//没用constexpr修饰，不能在类内初始化，只能在类外初始化
	static constexpr int p = 30;//可以在类内初始化
	static void f() {
		cout << "haha" << endl;
	}
private:
	static int give() {//必须为static
		return 66;
	};
};
int X::a = give();//X后面就在类的作用域中了。
//constexpr int X::p = 50;//不能提供初值，constexpr int X::p;才对，但是没有这条好像f1也能正常运行
int main() {
	cout << f1(X::p) << endl;//30
	X::f();//haha
	cout << X::a << endl;//66
	system("pause");
	return 0;
}
```

**静态成员vs普通成员**

* 静态数据成员可以是不完全类型，非静态不行

* 静态数据成员可以做类中成员函数的默认实参，非静态不行

  ```c++
  class X {
  public:
      static X a;//可以，此时X是虽然不完全但是a是静态的，可以定义不完全的静态成员
      X *mem;//可以定义不完全成员的指针
      X &r;//可以定义不完全类型成员的引用
      //X b;//不可以定义不完全成员的a
  	static int aa;
  	int bb;
  	static void f(int x = aa) {//静态成员可以做默认的实参，但是非静态的bb不可以
  		cout << "haha" << endl;
  	}    
  };
  ```

  这个奇葩的类怎么初始化，，我把int成员都删除了，然后自己定义了一个私有的方法，它内部调用无参构造函数：

  ```c++
  class X {
  public:
  	X(){}
  	static X a;//可以，此时X是虽然不完全但是a是静态的，可以定义不完全的静态成员
  	X *mem = nullptr;//可以定义不完全成员的指针
  	X &r = a;//可以定义不完全类型成员的引用	
  private:
  	static X get() {
  		return X();
  	}
  };
  
  X X::a = get();
  
  int main() {
  	X x;
  	system("pause");
  	return 0;
  }
  ```

  先把X::a在类外调用get方法赋值，get内执行无参构造函数，让r绑定在静态变量a上，下面这个函数可以正常执行。

  







