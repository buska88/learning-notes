# Linux C一站式学习

## chapter 30 进程

进程间通信方式：

不同进程的用户地址空间不同，每个进程的全局变量对其他进程不可见，所以进程之间的数据交换要通过内核，在内核中开辟缓冲区用于进程之间的数据交换：

https://gitee.com/buska88/reading-notes.git![image-20220518085551583](Linux C一站式学习.assets/image-20220518085551583.png

* 管道：本质上是内核的一个缓冲区，通过pipe创建，分为读端和写段供不同进程读写数据。父子进程通过管道交流的方式见书上

  为什么Linux的管道只能单向通信不能双向通信？Linux内核将其设计为只能单向通信的，而Solaris的管道就可以双向通信。原因就是管道的读指针只有一个，多进程读写会造成混乱。原因见https://www.zhihu.com/question/57509551

  ```
  具体一点则是，申请一个缓冲区，作为pipe()操作中匿名管道文件实体，缓冲区设俩指针，一个读指针，一个写指针，并保证读指针向前移动不能超过写指针，否则唤醒写进程并睡眠，直到读满需要的字节数。同理写指针向前也不能超过读指针，否则唤醒读进程并睡眠，直到写满要求的字节数。pipe()返回的两个文件句柄最后指向的其实是一个inode，只不过一个是read only一个是write only.试想同时两个进程读[或者写，假设只有两个进程]的后果，由于i_count会等于2——如果小于2则说明两个进程同时关闭了写句柄，因此会直接退出读函数。此时俩进程会分别认为对方才是写者而反复醒来，反复监测，然并卵没有数据，于是反复睡眠。如果有多个进程，俩进程同时读[或者写]，会造成数据混乱，因为读指针只有一个，而你不能保证读写的顺序。

  作者：知乎用户
  链接：https://www.zhihu.com/question/57509551/answer/153200357
  来源：知乎
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ```

# Linux shell

## 1 shell&环境变量

用户可以指定默认shell，shell提供对linux系统的交互式访问。

每个shell就是一个进程，有自己的进程id。

在一个shell进程内执行某个命令 如ps，此时shell所在进程会fork一个子进程执行ps命令，通过ps命令也可以看到，此时ps命令所在进程的ppid就是当前父进程的pid

每个父shell可以创建一个子shell，比如在bash，在一个shell中它们都是进程，有不同的进程id

进程列表：

当我们要在一行内执行多个命令时，可以使用分号分割不同命令：

```
pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls
```

此时每个命令都是在当前shell进程fork出的一个子进程执行的，当前shell并没有fork出一个子进程，如果想产生一个子shell来执行这些命令，可以用括号把这些命令括起来：

```
(pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)
```

括号的加入使命令列表变成了进程列表，生成了一个子shell来执行对应的命令。  

后台命令：

命令后加&可以在后台执行这个作业，如sleep 10&;使用jobs命令可以查看所有后台执行的作业

把进程列表放到后台执行：在子shell中进行繁重的处理工作，同时也不会让子shell的I/O受制于终端。下面这个例子就把涉及大量磁盘io的操作放到子shell中执行了而不是当前shell。【每个shell可以使用的IO资源有限制？】  

(tar -cf Rich.tar /home/rich ; tar -cf My.tar /home/christine)&  

协程：

协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。  

coproc sleep 10  #启动一个子shell并执行sleep 10

jobs命令可以显示出当前允许在后台模式的进程信息，还有协程信息。

内建命令&外部命令：前者就是shell内置的命令，不需要使用子进程来执行  (cd\exit)；而shell执行外部命令时会fork一个子进程来执行

环境变量：存储有关shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。

全局变量：全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。

要引用某个环境变量，需要在前面加上$引用变量的值。

如何自定义环境变量：等号给环境变量赋值，值可以是数值或字符串。  

```
my_variable="Hello World"
```

局部环境变量的作用域：在一个shell中定义的局部环境变量，在另一个shell中不可见。

如何使在一个shell内定义的变量全局可见？export my_variable  命令将变量到出为全局变量。子shell对环境变量的修改不会影响父shell中的值，即使通过export试图重新导出一次也是如此。

删除环境变量：使用unset命令，子shell中删除全局环境变量，父shell中的全局环境变量依然可用。    

PATH环境变量：当你在shell命令行界面中输入一个外部命令时，shell必须搜索系统来找到对应的程序 ，PATH环境变量定义了用于进行命令和程序查找的目录，PATH变量使用:分割。可以在新的程序加入到PATH中供程序查找。 

登录一个shell时，默认会从**启动文件**中读取一些命令。登录一个linux系统，会有一个**登录shell**直接与用户交互，登录shell会从不同的启动文件里读取命令 。对于bash，/etc/profile是默认的主启动文件，只要登录了linux系统那么 /etc/profile的命令就会被执行。剩余启动文件提供一个用户专属的启动文件来定义该用户所用到的环境变量，比如$HOME/.bashrc，不在etc文件下而是在用户自定义目录下，用户使用。

环境变量持久化：对于全局环境变量在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中，而不是直接放在/etc/profile文件中，否则升级了shell后所有环境变量就没了 。（意思是放到.sh文件后，.sh文件不会消失，而是可以执行一次导入到/etc/profile里）；个人环境变量对bash来说放到$HOME/.bashrc文件中。

环境变量可以作为数组使用：mytest=(one two three four five)  //$mytest显示第一个值，${mytest[i]} 显示数组第i个元素，${mytest[*]}显示整个数组、。

## 2 文件权限

明确概念：每个用户使用**用户名**和**密码**登录linux系统，系统为用户分配uid记录每个用户的权限。   

/etc/passwd：维护这台机器上用户名、密码、uid、用户默认shell等信息。

/etc/shadow  ：为系统上的每个用户账户都保存了一条记录，记录这个用户的密码信息，只有root用户才能访问。

用户组：组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限，GID是组id。/etc/group文件包含系统上用到的每个组的信息。

```
drwxr-xr-x 2 christine christine 4096 Apr 22 20:37 Desktop
```

 文件类型、(对象的属主、对象的属组、系统其他用户  )；文件的硬链接总数；文件属主的用户名；文件属组的组名；文件的大小（以字节为单位）；文件的上次修改时间；文件名或目录名。   

默认权限：新建一个文件，它的权限是多少？首先明确八进制安全模式，即(r--)对应二进制数100=》4，可以用0-7这8位数来表示一个文件的权限。每个文件是有全权限的，对于文件类型是666(全部可读写)，目录777(全部可读写执行)，而在/etc/profile  (也可能是其他的一些地方)有一个umask，代表不想给文件的权限，问文件创建时会用全权限减去umask得到文件的实际权限，如果umask=0022，那么一个目录的权限就是666-0022=644.

改变权限：chmod options mode file  ：修改file文件的权限，mode在**八进制模式下**是三个8进制数，分别表征用户、组、全局的权限；在**符号模式**下，是组合[ugoa…\][+-=\][rwxXstugo…\] ,表示给用户(组)或所有用户增加(+)设置(=)减去(-)xxx权限。如o+r表示给其他用户增加读权限。

chown命令用来改变文件的属主，chgrp命令用来改变文件的默认属组。  

共享文件：创建新文件时， Linux会用你默认的UID和GID给文件分配权限。想让其他人也能访问文件，要么改变其他用户所在安全组的访问权限，要么就给文件分配一个包含其他用户的新默认属组。这样有些麻烦，可以设置共享文件，Linux还为每个文件和目录存储了3个额外的信息位。
 设置用户ID（ SUID） ：当文件被用户使用时，程序会以文件属主的权限运行。
 设置组ID（ SGID） ：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。
 粘着位：进程结束后文件还驻留（粘着）在内存中。    

对于一个文件，要想使他共享，可以设置SUID使其它人访问文件时和文件属主权限相同；或者设置一个新目录，设置SGID位，设置这个目录的权限为777(所有人都可读写执行)，然后在这个目录里面创建的文件就是共享文件了。SGID在符号模式下用s表示

chmod g+s your_dict：给这个目录的组权限g加上SGID位。











